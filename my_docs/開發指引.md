這是一份為你的開發團隊準備的完整**技術規格書 (Technical Specification) 與開發指引**。

這份文件整合了我們之前討論的所有物理推導、穩定性策略（MRT）、與時間架構。你可以直接將此文件交給負責實作的工程師或研究員，作為開發的「聖經」。

---

# 專案代號：Real-time AI-LBM Simulator

### 技術開發規格書 v1.0

## 1. 專案背景與目標 (Background & Objective)

### 1.1 核心目標

開發一套基於深度學習（Deep Learning）的即時流體模擬器，用於建築風環境的快速迭代設計。

- **輸入**：2D 建築平面佈局（幾何邊界）。
- **輸出**：即時的風速場與壓力場視覺化。
- **性能要求**：在消費級 GPU 上達到 60 FPS，並具備物理時間的可控性（快轉/慢動作）。

### 1.2 技術路徑

本專案不使用傳統 CFD 直接求解（太慢），而是採用 **「LBM 生成數據 DL 模型學習 即時推理」** 的代理模型（Surrogate Model）策略。

1. **Ground Truth 生成器**：使用 **Taichi Lang** 開發 **2D MRT-LBM** 求解器。
2. **AI 核心**：使用 PyTorch 訓練神經網路（如 UNet/ResNet），學習流體的時間演化規律。
3. **即時引擎**：使用「累積器（Accumulator）」架構將 DL 推理與渲染解耦，實現物理時間同步。

---

## 2. 核心物理參數與限制 (Critical Parameters)

開發者必須嚴格遵守以下物理與數值限制，以確保數據的穩定性與正確性。

| 參數類別       | 參數名稱             | 數值 / 設定      | 說明 / 限制                      |
| -------------- | -------------------- | ---------------- | -------------------------------- |
| **物理環境**   | 特徵尺度 ()          |                  | 建築物寬度                       |
|                | 物理風速 ()          |                  | 目標模擬範圍                     |
|                | 物理黏度 ()          |                  | 空氣黏度 ()                      |
| **空間離散化** | 網格解析度 ()        | ** (10 cm)**     | **硬限制**，不可隨意更改         |
|                | 網格維度 (Grid Size) | 或               | 配合 DL 模型的 Tensor 尺寸       |
| **LBM 數值**   | 格子流速上限 ()      | \*\*\*\*         | 為了降噪與穩定，嚴禁超過 0.1     |
|                | 雷諾數處理 ()        | 截斷至           | 不需要跑真實的 ，會導致發散      |
| **時間同步**   | LBM 單步時間 ()      |                  | 由 與 自動換算                   |
|                | DL 採樣間隔 ()       | **100 ~ 200 步** | 每隔 步 LBM 存一筆數據           |
|                | DL 物理步長 ()       | \*\*\*\*         | 模型預測一次，物理世界前進的時間 |

---

## 3. 模組開發詳細要求 (Detailed Requirements)

### 3.1 模組 A：LBM 求解器 (Data Generator)

**技術棧**：Python + Taichi (GPU)
**算法核心**：D2Q9 MRT (Multi-Relaxation Time)

#### 開發重點：

1. **資料結構 (Data Layout)**：

-
- **必須使用 Structure of Arrays (SoA)**。
- Taichi 定義：`f = ti.Vector.field(9, dtype=ti.f32, shape=(nx, ny))` 並配合 `ti.root.dense(ti.ij, ...).place(f)`。

2. **穩定性機制 (MRT Collision)**：

- **嚴禁使用單鬆弛 BGK**（在粗網格下會炸）。
- 實作 D2Q9 MRT 矩陣運算。
- **關鍵參數**：
- 物理黏度鬆弛 。
- **鬼影模態鬆弛 (Ghost Modes)**：設定 。這是消除高頻噪音、防止模擬崩潰的關鍵。

3. **邊界條件**：

- 建築物：Bounce-back (反彈)。
- 邊界層：使用 Slip-wall (頂底) + Velocity Inlet (入口) + Neumann Outlet (出口)。

### 3.2 模組 B：深度學習模型 (The Surrogate)

**技術棧**：PyTorch

#### 開發重點：

1. **輸入特徵**：

- `Shape Mask` (建築物位置, Binary)。
- `Velocity_X`, `Velocity_Y`, `Pressure` (來自 時刻)。

2. **輸出目標**：

- `Velocity_X`, `Velocity_Y`, `Pressure` (預測 時刻)。

3. **數據標準化**：

- LBM 輸出的速度通常很小 ()。**必須 Normalization** 到 或 區間再餵給神經網路，否則梯度會消失。

### 3.3 模組 C：即時渲染器 (Real-time Iterator)

**技術棧**：Python (主控邏輯) + Taichi GUI / Matplotlib (視覺化)

#### 開發重點：

1. **時間解耦循環 (The Game Loop)**：

- 程式必須實作「累積器 (Accumulator)」邏輯。
- 是常數（例如 0.1s），不可變。
- 透過 `accumulator += real_time_delta * speed_multiplier` 來控制播放速度。

2. **Zero-Copy 傳輸**：

- 使用 `taichi_field.to_torch()` 與 `taichi_field.from_torch()` 進行數據交換。
- **避免**使用 `.numpy()`，這會導致 GPU CPU 的資料搬運，嚴重拖慢 FPS。

---

## 4. 常見問題與除錯指南 (Troubleshooting & QA)

### Q1: 為什麼模擬出來的渦流看起來比真實世界的大？

- **原因**：這是 2D 模擬的物理特性，稱為**逆能量級聯 (Inverse Energy Cascade)**。在 2D 中，小渦流傾向合併成大渦流，且缺乏 3D 的拉伸耗散機制。
- **對策**：這是正常現象。對於建築風環境的快速評估（舒適度、風口位置），這種「拓撲結構」是可接受的。不要試圖去對齊風洞實驗的 值。

### Q2: 模擬跑到一半出現 `NaN` 或花屏？

- **檢查點 1**： 是否超過 0.1？如果是，請降低時間步長或物理流速。
- **檢查點 2**：MRT 的 參數是否設為 ？如果設為 1.0 或更低，高頻噪音無法消除。
- **檢查點 3**：建築物邊緣是否過於尖銳？嘗試對 Mask 進行輕微的模糊處理或確保 Bounce-back 邏輯正確。

### Q3: 即時模擬畫面看起來「一頓一頓」的？

- **原因**： 太大（例如 0.25s），導致畫面跳躍。
- **對策**：

1. 重新生成數據，將 DL 採樣間隔從 500 降至 100~200。
2. 在渲染端實作 **線性插值 (Linear Interpolation)**：
   `Render_State = (1 - alpha) * State_Old + alpha * State_New`

---

## 5. 附錄：核心演算法偽代碼 (MRT Kernel)

請工程師參考此邏輯實作 Taichi Kernel：

```python
# D2Q9 MRT Collision 偽代碼
@ti.kernel
def mrt_collision():
    for i, j in f:
        if mask[i, j] == 0: # 僅流體計算
            # 1. 轉到矩空間 (Moment Space)
            # m = M * f
            rho = ...
            e   = ...
            # ... (共9個分量)

            # 2. 計算平衡態 (Equilibrium)
            e_eq = -2 * rho + 3 * (jx**2 + jy**2)
            # ...

            # 3. 執行鬆弛 (Relaxation)
            # 關鍵：S_ghost 設為 1.1 ~ 1.2
            e_new   = e   - s_ghost * (e - e_eq)
            p_xx_new = p_xx - s_nu  * (p_xx - p_xx_eq) # s_nu 負責物理黏度

            # 4. 轉回粒子空間 (Population Space)
            # f_new = M_inv * m_new
            f[i, j] = f_new

```
