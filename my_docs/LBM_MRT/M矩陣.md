### 一、 核心概念：基底變換 (Change of Basis)

我們可以把這想像成圖片處理中的顏色轉換：

- ** (粒子空間)** 就像是 **RGB** 格式。它告訴你「紅、綠、藍」各有多少。
- ** (矩空間)** 就像是 **HSL** 格式。它告訴你「色相、飽和度、亮度」是多少。

**操作 就是把 RGB 轉成 HSL。**
為什麼要做這件事？

- 在 RGB 裡，如果你想調整「亮度」，你必須同時調整 R、G、B 三個值，很難控制。
- 在 HSL 裡，你只要單獨調整 L (亮度)，完全不會影響到 H (色相)。

**MRT 也是一樣：**
我們不想直接去改 9 個方向的粒子數（很難分清哪個是噪音、哪個是黏度），所以我們先轉成 \*\*\*\*，把「密度」、「動量」、「應力（黏度）」、「鬼影（噪音）」分開，單獨處理完後再轉回去。

---

### 二、 具體數學操作：矩陣乘法

假設在網格的某一個點 上，你有 9 個粒子分佈值 。
這 9 個值組成一個行向量：

矩陣 是一個 的常數矩陣。
操作 就是將矩陣的 **每一行 (Row)** 與 ** 向量** 做 **內積 (Dot Product)**。

#### 標準 D2Q9 的 M 矩陣 (Lallemand & Luo 2000)

對應的粒子順序通常為：(中), (東), (北), (西), (南), (東北), (西北), (西南), (東南)。

---

### 三、 逐行拆解：每一行代表什麼物理意義？

這個矩陣的每一行數值不是隨便填的，它們是基於 **Gram-Schmidt 正交化** 推導出來的加權係數。讓我們看看它們實際上對 做了什麼運算：

#### 1. 第 0 行：密度 ()

- **操作**：把所有方向的粒子加起來。
- **意義**：這就是總質量（密度）。

#### 2. 第 3 行：X 軸動量 ()

對應矩陣第 3 行： `[0, 1, 0, -1, 0, 1, -1, -1, 1]`

- **操作**：(所有往右跑的粒子) - (所有往左跑的粒子)。
- **意義**：這就是 X 方向的淨動量。
- **注意**：垂直跑的 () 係數是 0，因為它們對 X 動量沒貢獻。

#### 3. 第 1 行：能量 ()

對應矩陣第 1 行： `[-4, -1, -1, -1, -1, 2, 2, 2, 2]`

- **操作**：
- 中間靜止的粒子 () 權重是 -4。
- 上下左右 (, 速度為 1) 權重是 -1。
- 四個角落 (, 速度為 ) 權重是 2。

- **意義**：這是一個與 **動能 ()** 相關的量。你可以把它看作是某種「能量偏差」。這是我們後面要用來消除噪音的關鍵通道。

#### 4. 第 7 行：正應力 ()

對應矩陣第 7 行： `[0, 1, -1, 1, -1, 0, 0, 0, 0]`

- **操作**：(水平方向粒子總和) - (垂直方向粒子總和)。
- **意義**：這代表了流體是被「拉長」還是被「壓扁」。這直接對應到 **黏滯力**。
- 在 MRT 碰撞中，我們會對這個 乘上 ，這就是物理上「黏度耗散能量」的實作過程。

---

### 四、 程式碼視角 (Taichi 實作)

在 Taichi 中，你不需要手寫這堆加法，直接定義矩陣即可。

```python
import taichi as ti

# 1. 定義常數矩陣 M
@ti.func
def get_M():
    return ti.Matrix([
        [ 1,  1,  1,  1,  1,  1,  1,  1,  1], # rho
        [-4, -1, -1, -1, -1,  2,  2,  2,  2], # e
        [ 4, -2, -2, -2, -2,  1,  1,  1,  1], # epsilon
        [ 0,  1,  0, -1,  0,  1, -1, -1,  1], # jx
        [ 0, -2,  0,  2,  0,  1, -1, -1,  1], # qx
        [ 0,  0,  1,  0, -1,  1,  1, -1, -1], # jy
        [ 0,  0, -2,  0,  2,  1,  1, -1, -1], # qy
        [ 0,  1, -1,  1, -1,  0,  0,  0,  0], # pxx
        [ 0,  0,  0,  0,  0,  1, -1,  1, -1]  # pxy
    ])

# 2. 實際操作過程
@ti.kernel
def collision_mrt():
    M = get_M()
    M_inv = M.inverse() # Taichi 會自動幫你算逆矩陣，通常是預計算好的常數

    # 對每一個網格點 (x, y)
    for x, y in f:
        # --- A. 讀取 f (Vector) ---
        f_vec = f[x, y]

        # --- B. 矩陣乘法 (f -> m) ---
        # 這就是你要的 "操作"：9x9 矩陣乘上 9x1 向量
        m_vec = M @ f_vec

        # --- C. 碰撞/鬆弛 (在 m 空間修改數值) ---
        # 計算平衡態 m_eq ... (略)
        # m_vec = m_vec - S * (m_vec - m_eq)

        # --- D. 逆矩陣乘法 (m -> f) ---
        f_new = M_inv @ m_vec

        f[x, y] = f_new

```

### 五、 總結

矩陣 的操作實際上就是：
**「把你手上的 9 張牌（粒子分佈），透過加減運算，重新組合成 9 個更有意義的指標（密度、動量、應力、噪音）。」**
